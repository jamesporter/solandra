{
  "Tiling": "const tiling = (p: PlayCanvas) => {\n  p.forTiling({ n: 20, margin: 0.1, type: \"square\" }, ([x, y], [dX, dY]) => {\n    p.setStrokeColour(120 + x * 120 + p.t * 50, 90 - 20 * y, 40);\n    p.proportionately([\n      [1, () => p.drawLine([x, y], [x + dX, y + dY])],\n      [2, () => p.drawLine([x + dX, y], [x, y + dY])]\n    ]);\n  });\n};\n\n",
  "Rainbow Drips": "const rainbow = (p: PlayCanvas) => {\n  p.withRandomOrder(\n    p.forTiling,\n    { n: 20, type: \"square\", margin: 0.1 },\n    ([i, j], [di, dj]) => {\n      p.doProportion(0.6, () => {\n        p.setStrokeColour(i * 100, 80, 30 + j * 30, 0.9);\n        p.lineWidth = 0.02 + 0.02 * (1 - i);\n        p.drawLine(\n          [i + di / 4, j + dj / 4],\n          [\n            i + (di * 3 * j * p.randomPolarity()) / 4,\n            j + (dj * 5 * (1 + p.random())) / 4\n          ]\n        );\n      });\n    }\n  );\n};\n\n",
  "Horizontal": "const horizontal = (p: PlayCanvas) => {\n  p.backgroundGradient(\n    new LinearGradient({\n      from: [0, 0],\n      to: [1, 0],\n      colours: [[0, { h: 0, s: 0, l: 95 }], [1, { h: 0, s: 0, l: 85 }]]\n    })\n  );\n  p.forHorizontal({ n: 20, margin: 0.1 }, ([x, y], [dX, dY]) => {\n    p.setStrokeColour(x * 360, 90, 40);\n    p.drawLine([x, y], [x + dX, y + dY]);\n  });\n};\n\n",
  "Vertical": "const vertical = (p: PlayCanvas) => {\n  p.backgroundGradient(\n    new LinearGradient({\n      from: [0, 0],\n      to: [0, 1],\n      colours: [[0, { h: 50, s: 40, l: 95 }], [1, { h: 30, s: 40, l: 90 }]]\n    })\n  );\n  p.forVertical({ n: 20, margin: 0.1 }, ([x, y], [dX, dY]) => {\n    const points = p.build(p.range, { from: x, to: x + dX, n: 20 }, vX => {\n      return p.perturb([vX, y + dY / 2], { magnitude: dY / 4 });\n    });\n    p.lineWidth = 0.01 / p.meta.aspectRatio;\n    p.setStrokeColour(y * 60, 90, 40);\n    p.draw(SimplePath.withPoints(points));\n  });\n};\n\n",
  "Curves Demo": "const curves1 = (p: PlayCanvas) => {\n  p.backgroundGradient(\n    new LinearGradient({\n      from: [0, 0],\n      to: [0, 1],\n      colours: [[0, { h: 215, s: 20, l: 90 }], [1, { h: 140, s: 20, l: 90 }]]\n    })\n  );\n  p.forTiling({ n: 12, margin: 0.1 }, ([x, y], [dX, dY]) => {\n    p.setStrokeColour(20 + x * 40, 90 - 20 * y, 50);\n    p.draw(\n      Path.startAt([x, y + dY]).addCurveTo([x + dX, y + dY], {\n        polarlity: p.randomPolarity(),\n        curveSize: x * 2,\n        curveAngle: x,\n        bulbousness: y\n      })\n    );\n  });\n};\n\n",
  "Flower": "const flower = (p: PlayCanvas) => {\n  const horizonOffset = p.random() * 0.25;\n  p.backgroundGradient(\n    new LinearGradient({\n      from: [0, 0],\n      to: [0, p.meta.bottom],\n      colours: [\n        [0, { h: 215, s: 90, l: 90 }],\n        [0.59 + horizonOffset, { h: 215, s: 100, l: 70 }],\n        [0.61 + horizonOffset, { h: 150, s: 90, l: 30 }],\n        [1, { h: 140, s: 90, l: 40 }]\n      ]\n    })\n  );\n\n  const { right, bottom } = p.meta;\n\n  const midX = right / 2;\n  const midY = bottom / 2;\n  const ir = p.random() * 0.025 + midX / 5;\n  const da = Math.PI / 10;\n\n  const start = p.perturb([midX, bottom * 0.95]);\n  const end: Point2D = [midX, midY];\n  const second = p.perturb(pointAlong(start, end, 0.4));\n\n  p.setStrokeColour(140, 50, 25);\n  p.lineWidth = 0.02;\n  p.draw(\n    SimplePath.startAt(start)\n      .addPoint(second)\n      .addPoint(end)\n      .chaiken({ n: 3 })\n  );\n\n  p.lineWidth = 0.01;\n  let path = Path.startAt([midX + ir, midY]);\n  for (let a = 0; a < Math.PI * 2; a += da) {\n    const pt: Point2D = [\n      midX + ir * Math.cos(a + da),\n      midY + ir * Math.sin(a + da)\n    ];\n\n    path.addCurveTo(pt, {\n      curveSize: 12,\n      bulbousness: 2,\n      curveAngle: p.random() / 6\n    });\n  }\n  const baseHue = p.random() * 290;\n  p.setFillGradient(\n    new RadialGradient({\n      start: [midX, midY],\n      end: [midX, midY],\n      rStart: 0,\n      rEnd: 2,\n      colours: [\n        [0, { h: 10 + baseHue, s: 90, l: 50, a: 0.95 }],\n        [0.3, { h: 70 + baseHue, s: 90, l: 40, a: 0.95 }]\n      ]\n    })\n  );\n  p.fill(path);\n  p.lineWidth = 0.005;\n\n  p.setFillColour(40, 90, 90);\n  p.fill(\n    new Arc({\n      at: [midX, midY],\n      r: ir / 1.4,\n      a: 0,\n      a2: Math.PI * 2\n    })\n  );\n};\n\n",
  "Chaiken": "const chaiken = (p: PlayCanvas) => {\n  const { right, bottom } = p.meta;\n\n  const midX = right / 2;\n  const midY = bottom / 2;\n  const ir = midX / 4;\n  const da = Math.PI / 10;\n\n  p.times(30, n => {\n    let points: Point2D[] = [];\n    for (let a = 0; a < Math.PI * 2; a += da) {\n      const rr = 2 * p.random() + 1;\n      points.push([\n        midX + ir * rr * Math.cos(a + da),\n        midY + ir * rr * Math.sin(a + da)\n      ]);\n    }\n    const sp = SimplePath.startAt(points[0]);\n    points.slice(1).forEach(p => sp.addPoint(p));\n    sp.close();\n    sp.chaiken({ n: 4, looped: true });\n    p.lineWidth = 0.005;\n    p.setStrokeColour(190 + n, 90, 40, 0.75);\n    p.draw(sp);\n  });\n};\n\n",
  "Tiled Curves": "const tilesOfChaiken = (p: PlayCanvas) => {\n  p.forTiling({ n: 6, type: \"square\", margin: 0.1 }, ([x, y], [dX, dY]) => {\n    const midX = x + dX / 2;\n    const midY = y + dY / 2;\n    const ir = dX / 4;\n    const da = Math.PI / 10;\n\n    p.times(3, n => {\n      let points: Point2D[] = [];\n      for (let a = 0; a < Math.PI * 2; a += da) {\n        const rr = 2 * p.random() + 1;\n        points.push([\n          midX + ir * rr * Math.cos(a + da),\n          midY + ir * rr * Math.sin(a + da)\n        ]);\n      }\n      const sp = SimplePath.startAt(points[0]);\n      points.slice(1).forEach(p => sp.addPoint(p));\n      sp.close();\n      sp.chaiken({ n: 2 + n, looped: true });\n      p.lineWidth = 0.005;\n      p.setStrokeColour(190 + x * 100, 90, 40 + y * 10, 0.75 * ((n + 3) / 5));\n      p.draw(sp);\n    });\n  });\n};\n\n",
  "Around a Circle": "const circle = (p: PlayCanvas) => {\n  p.times(10, n => {\n    p.setStrokeColour(0, 0, n + 10, (0.75 * (n + 1)) / 10);\n    const points = p.build(p.aroundCircle, { n: 20 }, pt => p.perturb(pt));\n    const sp = SimplePath.withPoints(points)\n      .close()\n      .chaiken({ n: n + 1, looped: true });\n    p.draw(sp);\n  });\n};\n\n",
  "Arcs": "const arcs = (p: PlayCanvas) => {\n  const { bottom, right } = p.meta;\n\n  const cX = right / 2;\n  const cY = bottom / 2;\n\n  p.times(19, n => {\n    p.setFillColour(n * 2.5, 90, 50, 0.5);\n    p.fill(\n      new Arc({\n        at: [cX, cY],\n        r: (0.3 * Math.sqrt(n + 1)) / 3,\n        a: (n * Math.PI) / 10,\n        a2: ((n + 2) * Math.PI) / 10\n      })\n    );\n  });\n};\n\n",
  "Noise": "const noise = (p: PlayCanvas) => {\n  p.forTiling({ n: 12, margin: 0.1 }, ([x, y], [dX, dY]) => {\n    const v = perlin2(x, y) * Math.PI * 2;\n    p.setFillColour(p.t * 10 + 120 + v * 20, 80, 40);\n    p.fill(\n      new Arc({\n        at: [x + dX / 2, y + dY / 2],\n        r: dX / 2,\n        a: p.t + v,\n        a2: p.t + v + Math.PI / 2\n      })\n    );\n  });\n};\n\n",
  "Noise Field": "const noiseField = (p: PlayCanvas) => {\n  const delta = 0.01;\n  const s = 8;\n  p.lineWidth = 0.0025;\n\n  p.times(250, n => {\n    p.setStrokeColour(195 + n / 12.5, 90, 30, 0.7);\n    let pt = p.randomPoint;\n    const sp = SimplePath.startAt(pt);\n    while (true) {\n      const a = Math.PI * 2 * perlin2(pt[0] * s, pt[1] * s);\n      const nPt = add(pt, [delta * Math.cos(a), delta * Math.sin(a)]);\n      if (p.inDrawing(nPt)) {\n        pt = nPt;\n        sp.addPoint(nPt);\n      } else {\n        break;\n      }\n    }\n    p.draw(sp.chaiken({ n: 2 }));\n  });\n};\n\n",
  "Rectangles": "const rectangles = (p: PlayCanvas) => {\n  p.lineWidth = 0.005;\n\n  p.forTiling({ n: 12, margin: 0.1 }, ([x, y], [dX, dY]) => {\n    p.setFillColour(214 * x, 100, 35 + 10 * y, 0.7);\n    p.fill(\n      new Rect({\n        at: [x + dX / 8, y + dY / 8],\n        w: dX * p.random() * 0.75,\n        h: dY * p.random() * 0.75\n      })\n    );\n  });\n};\n\n",
  "Rectangles Divided": "const rectanglesDivided = (p: PlayCanvas) => {\n  p.lineWidth = 0.005;\n  const { right, bottom } = p.meta;\n\n  new Rect({ at: [0.1, 0.1], w: right - 0.2, h: bottom - 0.2 })\n    .split({ orientation: \"vertical\", split: [1, 1.5, 2, 2.5] })\n    .forEach((r, i) => {\n      p.setFillGradient(\n        new LinearGradient({\n          from: r.at,\n          to: [r.at[0], r.at[1] + r.h],\n          colours: [\n            [0, { h: i * 10, s: 90, l: 60 }],\n            [1, { h: i * 10, s: 60, l: 40 }]\n          ]\n        })\n      );\n      p.fill(r);\n      p.draw(r);\n    });\n};\n\n",
  "Mondrianish": "const mondrian = (p: PlayCanvas) => {\n  const { right, bottom } = p.meta;\n\n  let rs = [new Rect({ at: [0.1, 0.1], w: right - 0.2, h: bottom - 0.2 })];\n  p.times(4, () => {\n    rs = rs.flatMap(r => {\n      if (r.w > 0.1 && r.h > 0.1) {\n        return p.proportionately([\n          [0.6, () => [r]],\n          [\n            1,\n            () =>\n              r.split({\n                orientation: \"horizontal\",\n                split: p.samples(3, [1, 2, 2.5, 3])\n              })\n          ],\n          [\n            1,\n            () =>\n              r.split({\n                orientation: \"vertical\",\n                split: p.samples(3, [1, 1.2, 1.5, 2])\n              })\n          ]\n        ]);\n      } else {\n        return [r];\n      }\n    });\n  });\n\n  rs.map(r => {\n    p.doProportion(0.3, () => {\n      p.setFillColour(p.sample([10, 60, 200]), 80, 50);\n      p.fill(r);\n    });\n    p.draw(r);\n  });\n};\n\n",
  "Hello World": "const helloWorld = (p: PlayCanvas) => {\n  const { bottom, aspectRatio } = p.meta;\n  p.range(\n    {\n      from: 0.1,\n      to: bottom - 0.1,\n      n: 10\n    },\n    n => {\n      p.setStrokeColour(n * aspectRatio * 50, 20, 20, 0.75);\n      for (let align of [\"right\", \"center\", \"left\"] as const) {\n        p.drawText(\n          {\n            at: [n * aspectRatio, n],\n            size: 0.2,\n            sizing: \"fixed\",\n            align,\n            weight: \"600\"\n          },\n          \"Hello\"\n        );\n      }\n      p.setFillColour(n * aspectRatio * 50, 80, 50, 0.9);\n\n      p.fillText(\n        {\n          at: [n * aspectRatio, n],\n          size: 0.2,\n          sizing: \"fixed\",\n          align: \"center\",\n          weight: \"600\"\n        },\n        \"Hello\"\n      );\n    }\n  );\n};\n\n",
  "Circle Labels": "const circleText = (p: PlayCanvas) => {\n  p.aroundCircle({ radius: 0.25, n: 12 }, ([x, y], i) => {\n    p.times(5, n => {\n      p.setFillColour(i * 5 + n, 75, 35, 0.2 * n);\n      p.fillText(\n        {\n          at: p.perturb([x, y]),\n          size: 0.05,\n          align: \"left\"\n        },\n        (i + 1).toString()\n      );\n    });\n  });\n};\n\n",
  "Script-ish": "const scriptLike = (p: PlayCanvas) => {\n  const { bottom, aspectRatio } = p.meta;\n\n  p.range({ from: 0.1, to: bottom - 0.1, n: 5 }, m => {\n    let points: Point2D[] = [];\n    p.setStrokeColour(215, 40, 30 - 30 * m);\n    p.range({ from: 0.1, to: 0.9, n: 60 }, n => {\n      points.push([\n        n + perlin2(n * 45 + m * 67, 20) / 12,\n        m + perlin2(n * 100 + m * 100, 0.1) / (6 * aspectRatio)\n      ]);\n    });\n    p.draw(SimplePath.withPoints(points).chaiken({ n: 4 }));\n  });\n};\n\n",
  "Doodles": "const doodles = (p: PlayCanvas) => {\n  p.forTiling({ n: 7, type: \"square\", margin: 0.1 }, ([x, y], [dX, dY]) => {\n    const center = add([x, y], scale([dX, dY], 0.5));\n    let path = Path.startAt(center);\n    p.setStrokeColour(100 * x + y * 33, 60 + 45 * y, 40);\n    p.lineWidth = 0.005;\n    p.withRandomOrder(\n      p.aroundCircle,\n      { at: center, radius: dX / 2.8, n: 7 },\n      pt => path.addCurveTo(pt)\n    );\n    path.addCurveTo(center);\n    p.draw(path);\n  });\n};\n\n",
  "Circles": "const circles = (p: PlayCanvas) => {\n  p.background(120, 5, 95);\n  p.forTiling({ n: 10, type: \"square\", margin: 0.1 }, (pt, delta) => {\n    p.setFillColour(pt[0] * 100, 80, 50);\n    const r = Math.sqrt(1.2 * pt[0] * pt[1]);\n    p.fill(\n      new Ellipse({\n        at: add(pt, scale(delta, 0.5)),\n        align: \"center\",\n        w: delta[1] * r,\n        h: delta[1] * r\n      })\n    );\n  });\n};\n\n",
  "Bubbles": "const circles2 = (p: PlayCanvas) => {\n  p.background(220, 30, 90);\n  p.withRandomOrder(\n    p.forTiling,\n    { n: 10, type: \"square\", margin: 0.1 },\n    (pt, delta) => {\n      p.setFillColour(150 + pt[0] * 50, 80, 50, 0.9);\n      p.setStrokeColour(150, 40, 20);\n      p.lineWidth = 0.005;\n      const r = Math.sqrt(1.2 * pt[0] * pt[1]) * p.sample([0.7, 1.1, 1.3]);\n      const e = new Circle({\n        at: add(pt, scale(delta, 0.5)),\n        align: \"center\",\n        r: delta[1] * r\n      });\n\n      p.fill(e);\n      p.draw(e);\n    }\n  );\n};\n\n",
  "Ellipses Demo": "const ellipses = (p: PlayCanvas) => {\n  p.background(0, 0, 100);\n  p.withRandomOrder(\n    p.forTiling,\n    { n: 15, type: \"square\", margin: 0.1 },\n    (pt, delta) => {\n      const [x, y] = pt;\n      p.setFillColour(150 + perlin2(x * 10, 1) * 50, 80, 50, 0.9);\n      p.setStrokeColour(150, 40, 100);\n      p.lineWidth = 0.005;\n      const r = Math.sqrt(\n        1.8 * (0.1 + Math.abs(x - 0.5)) * (0.1 + Math.abs(y - 0.5))\n      );\n      const e = new Ellipse({\n        at: add(pt, scale(delta, 0.5)),\n        align: \"center\",\n        w: delta[1] * r * 3,\n        h: delta[1] * 1.2\n      });\n      p.fill(e);\n      p.draw(e);\n    }\n  );\n};\n\n",
  "Gradient Demo 1": "const gradients1 = (p: PlayCanvas) => {\n  const { right, bottom } = p.meta;\n  p.setFillGradient(\n    new LinearGradient({\n      from: [0, 0],\n      to: [right, bottom],\n      colours: [\n        [0, { h: 210 + p.t * 100, s: 80, l: 60 }],\n        [0.5, { h: 250 + p.t * 100, s: 80, l: 60 }],\n        [1.0, { h: 280 + p.t * 100, s: 80, l: 60 }]\n      ]\n    })\n  );\n  p.fill(new Rect({ at: [0, 0], w: right, h: bottom }));\n};\n\n",
  "Gradient Demo 2": "const gradients2 = (p: PlayCanvas) => {\n  const { right, bottom, center } = p.meta;\n\n  p.setFillGradient(\n    new RadialGradient({\n      start: center,\n      end: [right, bottom],\n      rStart: 0.0,\n      rEnd: 2 * Math.max(bottom, right),\n      colours: [\n        [0, { h: 0 + p.t * 40, s: 80, l: 60 }],\n        [0.7, { h: 50 + p.t * 20, s: 90, l: 60 }],\n        [1.0, { h: 1000 + p.t * 20, s: 80, l: 60 }]\n      ]\n    })\n  );\n  p.fill(new Rect({ at: [0, 0], w: right, h: bottom }));\n};\n\n",
  "Gradient Demo 3": "const gradients3 = (p: PlayCanvas) => {\n  const { right, bottom, center } = p.meta;\n  p.setFillGradient(\n    new LinearGradient({\n      from: [0, 0],\n      to: [0, bottom],\n      colours: [\n        [0, { h: 215, s: 80, l: 60 }],\n        [0.5, { h: 215, s: 80, l: 60 }],\n        [0.55, { h: 240, s: 80, l: 60 }],\n        [1.0, { h: 240, s: 80, l: 60 }]\n      ]\n    })\n  );\n  p.fill(new Rect({ at: [0, 0], w: right, h: bottom }));\n\n  p.setFillGradient(\n    new RadialGradient({\n      start: center,\n      end: center,\n      rStart: 0.0,\n      rEnd: 2 * bottom,\n      colours: [\n        [0, { h: 0, s: 80, l: 60 }],\n        [0.02, { h: 0, s: 80, l: 60 }],\n        [0.1, { h: 0, s: 80, l: 60, a: 0.3 }],\n        [0.15, { h: 0, s: 80, l: 60, a: 0.05 }],\n        [1.0, { h: 0, s: 80, l: 60, a: 0.03 }]\n      ]\n    })\n  );\n  p.fill(new Rect({ at: [0, 0], w: right, h: bottom }));\n};\n\n",
  "Gradient Demo 4": "const gradients4 = (p: PlayCanvas) => {\n  const { right, bottom } = p.meta;\n  const corners: Point2D[] = [[0, 0], [right, 0], [right, bottom], [0, bottom]];\n  const hues = [10, 215, 50, 190];\n\n  p.background(0, 0, 5);\n  for (let i = 0; i < 4; i++) {\n    const from = corners[i];\n    const to = corners[(i + 2) % 4];\n\n    p.setFillGradient(\n      new LinearGradient({\n        from,\n        to,\n        colours: [\n          [0, { h: hues[i], s: 90, l: 90, a: 0.01 }],\n          [0.4, { h: hues[i], s: 90, l: 90, a: 0.1 }],\n          [0.5, { h: hues[i], s: 90, l: 90, a: 0.9 }],\n          [0.5, { h: hues[i], s: 90, l: 90, a: 0.1 }],\n          [1, { h: hues[i], s: 90, l: 90, a: 0.01 }]\n        ]\n      })\n    );\n    p.fill(new Rect({ at: [0, 0], w: right, h: bottom }));\n  }\n};\n\n",
  "Gradient Demo 5": "const gradients5 = (p: PlayCanvas) => {\n  const { right, bottom } = p.meta;\n  const corners: Point2D[] = [[0, 0], [right, 0], [right, bottom], [0, bottom]];\n  const hues = [10, 215, 50, 190];\n\n  p.background(0, 0, 5);\n  p.forHorizontal({ n: 30 }, (from, [dX, _]) => {\n    const to = add(from, [dX * p.poisson(3), 0]);\n    const l = 60;\n    p.setFillGradient(\n      new LinearGradient({\n        from,\n        to,\n        colours: [\n          [0, { h: 40, s: 90, l, a: 0.0 }],\n          [0, { h: 40, s: 90, l, a: 0.7 }],\n          [1, { h: 0, s: 80, l, a: 0.01 }],\n          [1, { h: 0, s: 90, l, a: 0.0 }]\n        ]\n      })\n    );\n    p.fill(new Rect({ at: [0, 0], w: right, h: bottom }));\n  });\n};\n\n",
  "Gradient Demo 6": "const sunsetThroughBlinds = (p: PlayCanvas) => {\n  const { right, bottom, center } = p.meta;\n\n  p.setFillGradient(\n    new RadialGradient({\n      start: add(center, [0, 0.2]),\n      end: add(center, [0, 0.4]),\n      rStart: 0.0,\n      rEnd: 2 * bottom * right,\n      colours: [\n        [0, { h: 0, s: 80, l: 60 }],\n        [0.6, { h: 215, s: 80, l: 60 }],\n        [1.0, { h: 230, s: 80, l: 60 }]\n      ]\n    })\n  );\n  p.fill(new Rect({ at: [0, 0], w: right, h: bottom }));\n\n  p.forVertical({ n: 15 }, (pt, [w, h]) => {\n    p.setFillGradient(\n      new LinearGradient({\n        from: pt,\n        to: add(pt, [0, h]),\n        colours: [\n          [0, { h: 40, s: 40, l: 90, a: 0.9 }],\n          [0.5, { h: 40, s: 40, l: 50, a: 0.8 }],\n          [0.55, { h: 40, s: 40, l: 50, a: 0.1 }],\n          [1, { h: 40, s: 40, l: 90, a: 0.1 }]\n        ]\n      })\n    );\n    p.fill(new Rect({ at: pt, w, h }));\n  });\n};\n\n",
  "Gaussian": "const randomness1 = (p: PlayCanvas) => {\n  const { bottom } = p.meta;\n  p.forHorizontal(\n    {\n      n: 100,\n      margin: 0.1\n    },\n    ([x, y], [dX, dY]) => {\n      p.setFillGradient(\n        new LinearGradient({\n          from: [0, 0],\n          to: [0, bottom],\n          colours: [\n            [0, { h: 245, s: 80, l: 40 }],\n            [0.45, { h: 180, s: 80, l: 40 }],\n            [0.55, { h: 40, s: 80, l: 40 }],\n            [1, { h: 0, s: 80, l: 40 }]\n          ]\n        })\n      );\n\n      const v = p.gaussian();\n      p.fill(\n        new Rect({\n          at: [x, y + dY / 2],\n          w: dX,\n          h: (dY * v) / 5\n        })\n      );\n    }\n  );\n};\n\n",
  "Gaussian 2": "const randomness1b = (p: PlayCanvas) => {\n  p.times(25, n => {\n    p.setFillColour(175 + n, 80, 50, 0.4);\n    const values = p\n      .build(p.times, 50, () => p.gaussian())\n      .sort((a, b) => (a > b ? -1 : 1));\n    const min = Math.min(...values);\n    const max = Math.max(...values);\n    const range = max - min;\n    p.forHorizontal(\n      {\n        n: values.length,\n        margin: 0.1\n      },\n      ([x, y], [dX, dY], _c, i) => {\n        const h = dY * ((values[i] - min) / range);\n        p.fill(\n          new Rect({\n            at: [x + n * 0.04 * dX, y + dY / 2 - h / 2],\n            w: dX * 0.2,\n            h\n          })\n        );\n      }\n    );\n  });\n};\n\n",
  "Gaussian 3": "const randomness1c = (p: PlayCanvas) => {\n  p.background(205, 20, 85);\n  p.forTiling({ n: 20, type: \"square\", margin: 0.1 }, (_pt, [w], at) => {\n    p.setFillColour(195, 70, 40);\n    p.fill(new Circle({ at, r: w * 0.45 }));\n\n    p.setFillColour(205, 70, 80);\n    p.fill(new Circle({ at: p.perturb(at, { magnitude: w / 3 }), r: w * 0.3 }));\n  });\n};\n\n",
  "Poisson": "const randomness2 = (p: PlayCanvas) => {\n  p.background(320, 10, 90);\n  p.forTiling({ n: 50, margin: 0.1 }, (pt, delta) => {\n    const v = p.poisson(4);\n    p.times(v, n => {\n      p.setFillColour(40 - n * 20, 80, 50, 1 / n);\n      p.fill(\n        new Ellipse({\n          at: add(pt, scale(delta, 0.5)),\n          w: (n * delta[0]) / 5,\n          h: (n * delta[0]) / 5\n        })\n      );\n    });\n  });\n};\n\n",
  "Curves": "const curves = (p: PlayCanvas) => {\n  p.background(215, 30, 20);\n  p.forHorizontal({ n: 75 }, ([x, y], [dX, dY]) => {\n    const vPts = [0, 0, 0, 0].map(_ => p.poisson(5) + 2);\n    const total = sum(vPts);\n    let nVPts = vPts.map(p => (dY * p) / total);\n    nVPts = [y - 0.1].concat(\n      [3, 2, 1, 0].map(i => y + 1.2 * sum(nVPts.slice(i)))\n    );\n    const nHPts = nVPts.map(p => x + dX * 12 * perlin2(10 + p * 60, x * 20));\n    const points = zip2(nHPts, nVPts);\n    const path = SimplePath.withPoints(points);\n    path.chaiken({ n: 4 });\n    p.setStrokeColour(p.uniformRandomInt({ from: -40, to: 60 }), 90, 60, 0.95);\n    p.draw(path);\n  });\n};\n\n",
  "Transforms Demo": "const transforms = (p: PlayCanvas) => {\n  p.forTiling({ n: 8, type: \"square\", margin: 0.1 }, ([x, y], [dX, dY]) => {\n    p.setFillColour(120 + x * 100, 90, 50);\n    p.withTranslation([x + dX / 2, y + dY / 2], () =>\n      p.withRotation(x + y + p.t, () => {\n        p.fill(new Rect({ at: [-dX / 4, -dY / 4], w: dX / 2, h: dY / 2 }));\n      })\n    );\n  });\n};\n\n",
  "Transforms Demo 2": "const transforms2 = (p: PlayCanvas) => {\n  p.background(0, 0, 0);\n  const baseSize = (1 + Math.sin(2 * p.t)) / 2;\n  const { bottom: h } = p.meta;\n  p.forTiling({ n: 32, type: \"square\" }, ([x, y], [dX, dY]) => {\n    p.setFillColour(320 - x * 100 + p.t * 10, 90, 50, 0.8);\n    p.withTranslation([x + dX / 2, y + dY / 2], () =>\n      p.withRotation(x + y + p.t * 2, () =>\n        p.withScale(\n          [\n            baseSize + 6 * Math.abs(0.5 - x),\n            baseSize + 12 * Math.abs(0.5 - y / h)\n          ],\n          () => {\n            p.fill(new Rect({ at: [-dX / 4, -dY / 4], w: dX / 2, h: dY / 2 }));\n          }\n        )\n      )\n    );\n  });\n};\n\n",
  "Transforms Demo 3": "const transforms3 = (p: PlayCanvas) => {\n  const { bottom: h } = p.meta;\n  const a = Math.sin(p.t);\n  p.forHorizontal({ n: 20, margin: 0.3 }, ([x, y], [dX, dY]) => {\n    p.range({ from: 0, to: 2 * Math.PI, n: 12 }, n =>\n      p.withTranslation([x + dX / 2, (h * n) / 6 + dY / 6], () => {\n        p.withRotation(x - n + a, () => {\n          p.setFillColour(360 - n * 20, 90, 30, 0.5);\n          p.fill(new Rect({ at: [-dX / 2, -dY / 2], w: dX / 4, h: 2 * dY }));\n        });\n      })\n    );\n  });\n};\n\n",
  "Time": "const time = (p: PlayCanvas) => {\n  p.background(50, 20, 90);\n  const times = 4;\n  p.forHorizontal({ n: 20, margin: 0.1 }, ([x, y], [dX, dY]) => {\n    p.times(times, n => {\n      const h = dY * 0.5 * (1 + perlin2(x, 100 + n + p.t / 4));\n      p.setFillColour((n * 60) / times, 80, 60);\n      p.fill(\n        new Rect({\n          at: [x + (dX / times) * n, y + dY - h],\n          h,\n          w: dX / times\n        })\n      );\n    });\n  });\n};\n\n",
  "Clipping Demo": "const clipping = (p: PlayCanvas) => {\n  const { center, bottom, right } = p.meta;\n  const size = Math.min(bottom, right) * 0.8;\n  p.background(120 + p.t * 50, 40, 90);\n  p.lineWidth = 0.005;\n  p.range({ from: 1, to: 4, n: 4 }, n =>\n    p.withTranslation([0.037 * n * n, bottom * 0.037 * n * n], () =>\n      p.withScale([0.1 * n, 0.1 * n], () =>\n        p.withClipping(new Ellipse({ at: center, w: size, h: size }), () =>\n          p.forTiling(\n            { n: 60 / (8 - n), type: \"square\" },\n            ([x, y], [dX, dY]) => {\n              p.setStrokeColour(120 + x * 120 + p.t * 50, 90 - 20 * y, 40);\n              p.proportionately([\n                [1, () => p.drawLine([x, y], [x + dX, y + dY])],\n                [2, () => p.drawLine([x + dX, y], [x, y + dY])],\n                [1, () => p.drawLine([x, y], [x, y + dY])]\n              ]);\n            }\n          )\n        )\n      )\n    )\n  );\n};\n\n",
  "Rounded Rectangles Demo": "const roundedRects = (p: PlayCanvas) => {\n  p.forTiling(\n    { n: 5, type: \"proportionate\", margin: 0.1 },\n    ([x, y], [dX, dY]) => {\n      p.setFillColour(p.t * 50 + 150 + x * 100, y * 40 + 60, 40);\n      p.fill(\n        new RoundedRect({\n          at: [x + dX / 6, y + dY / 6],\n          w: (dX * 2) / 3,\n          h: (dY * 2) / 3,\n          r: dX / 8\n        })\n      );\n    }\n  );\n};\n\n",
  "Cards": "const cards = (p: PlayCanvas) => {\n  p.forTiling({ n: 6, type: \"square\", margin: 0.05 }, ([x, y], [dX, dY]) => {\n    p.withClipping(\n      new RoundedRect({\n        at: [x + dX / 6, y + dX / 4],\n        w: (dX * 2) / 3,\n        h: dY / 2,\n        r: dX / 12\n      }),\n      () => {\n        p.setFillColour(175 + x * 60 + y * 100, y * 40 + 60, 40);\n        p.fill(\n          new Rect({\n            at: [x + dX / 6, y + dX / 4],\n            w: (dX * 2) / 3,\n            h: dY / 2\n          })\n        );\n\n        p.setFillColour(0, 0, 100, 0.4);\n        p.times(5, () =>\n          p.fill(\n            new Ellipse({\n              at: p.perturb([x + dX / 2, y + dY / 2]),\n              w: dX / 2,\n              h: dX / 2\n            })\n          )\n        );\n      }\n    );\n  });\n};\n\n",
  "Polygons": "const polygons = (p: PlayCanvas) => {\n  p.background(330, 70, 30);\n  let n = 3;\n  p.forTiling({ n: 4, type: \"square\", margin: 0.1 }, ([x, y], [dX, dY]) => {\n    p.setFillColour(180 + 40 * x, 50 + 50 * y, 60);\n    p.fill(\n      new RegularPolygon({\n        at: [x + dX / 2, y + dY / 2],\n        n,\n        r: dX / 2.1,\n        a: p.t\n      })\n    );\n    n++;\n  });\n};\n\n",
  "Polygons 2": "const polygons2 = (p: PlayCanvas) => {\n  p.background(330, 70, 10);\n  p.times(5, n => {\n    const sides = 10 - n;\n    const r = 0.4 - n * 0.05;\n    p.setFillColour(330, 70, 10 + n * 12);\n    p.fill(\n      new RegularPolygon({\n        at: p.meta.center,\n        n: sides,\n        r\n      })\n    );\n  });\n};\n\n",
  "Polygons 3": "const polygons3 = (p: PlayCanvas) => {\n  p.background(210, 70, 90);\n  p.forHorizontal({ n: 4, margin: 0.1 }, (_pt, [dX], c, i) => {\n    p.setFillColour([215, 225, 235, 245][i], 90, 30);\n    p.fill(\n      new RegularPolygon({\n        at: c,\n        n: 6,\n        r: dX / 2,\n        a: (i * Math.PI) / 6 + p.t * (i % 2 === 0 ? 1 : -1)\n      })\n    );\n  });\n};\n\n",
  "Stars": "const stars = (p: PlayCanvas) => {\n  let n = 3;\n  p.background(30, 20, 80);\n  p.forTiling({ n: 4, type: \"square\", margin: 0.1 }, ([x, y], [dX, dY]) => {\n    p.setFillColour(20 + 30 * x, 25 + 75 * y, 45 + 5 * (1 + Math.sin(p.t + x)));\n    p.fill(\n      new Star({\n        at: [x + dX / 2, y + dY / 2],\n        n,\n        r: (dX * (2.2 + Math.cos(x + y + p.t))) / 6.1,\n        a: p.t\n      })\n    );\n    n++;\n  });\n};\n\n",
  "Hatching Demo 1": "const hatching = (p: PlayCanvas) => {\n  p.lineWidth = 0.001;\n  p.range({ from: 1, to: 0.2, n: 4, inclusive: true }, n => {\n    p.setStrokeColour(215 - n * 75, 90, 10 + n * 30);\n    const s = (1.5 + Math.cos(p.t)) / 2;\n    p.draw(\n      new Hatching({\n        at: p.meta.center,\n        r: n * s,\n        delta: 0.01,\n        a: (n * 16) / Math.PI\n      })\n    );\n  });\n};\n\n",
  "Hatching Demo 2": "const hatching2 = (p: PlayCanvas) => {\n  p.background(0, 0, 10);\n  p.lineWidth = 0.005;\n  const { center } = p.meta;\n  const count = p.uniformRandomInt({ from: 5, to: 35 });\n  const points = p.build(p.times, count, n => {\n    return p.perturb(center, { magnitude: 0.1 * n });\n  });\n  points.forEach(pt => {\n    p.setStrokeColour(15 + pt[0] * 50, 90, 40, 0.9);\n    const r = 0.1 + 0.15 * p.random();\n    p.withClipping(new Circle({ at: pt, r }), () =>\n      p.draw(\n        new Hatching({\n          at: pt,\n          r: 1,\n          delta: 0.01,\n          a: (pt[1] * Math.PI) / 12\n        })\n      )\n    );\n  });\n};\n\n",
  "More Arcs": "const moreArcs = (p: PlayCanvas) => {\n  const s = p.meta.right / 4;\n  p.times(100, () => {\n    const a = p.random() * 2 * Math.PI;\n    const a2 = a + p.random();\n    p.setFillColour(a * 30, 90, 30, 0.2);\n    p.fill(\n      new HollowArc({\n        at: p.meta.center,\n        r: s + (p.random() * s) / 2,\n        r2: s - (p.random() * s) / 2,\n        a,\n        a2\n      })\n    );\n  });\n};\n\n",
  "Even More Arcs": "const evenMoreArcs = (p: PlayCanvas) => {\n  p.background(30, 50, 90);\n  p.times(24, () => {\n    const a = p.random() * Math.PI * 2;\n    const r = p.sample([0.2, 0.25, 0.3, 0.35, 0.4]);\n    p.setFillColour(p.sample([20, 30, 35, 40]), 90, 60, 0.8);\n    p.fill(\n      new HollowArc({\n        at: p.meta.center,\n        a,\n        a2: a + p.gaussian({ mean: 0.5, sd: 0.2 }),\n        r,\n        r2: r - 0.1\n      })\n    );\n  });\n\n  p.times(48, () => {\n    const a = p.random() * Math.PI * 2;\n    const r = p.sample([0.325, 0.375, 0.425]);\n    p.setFillColour(p.sample([20, 30, 35, 40]), 80, 30, 0.95);\n    p.fill(\n      new HollowArc({\n        at: p.meta.center,\n        a,\n        a2: a + Math.PI / 96,\n        r,\n        r2: r - 0.3\n      })\n    );\n  });\n};\n\n",
  "Curls": "const curls = (p: PlayCanvas) => {\n  const baseColour = p.uniformRandomInt({ from: 150, to: 250 });\n  p.background(baseColour, 20, 90);\n  p.lineStyle = {\n    cap: \"round\"\n  };\n  p.setFillColour(baseColour, 60, 30);\n  p.setStrokeColour(baseColour - 40, 80, 35, 0.9);\n  p.times(p.uniformRandomInt({ from: 20, to: 100 }), () => {\n    const c = p.randomPoint;\n    let tail = p.perturb(c, { magnitude: 0.2 });\n    while (distance(c, tail) < 0.1) {\n      tail = p.perturb(c, { magnitude: 0.2 });\n    }\n    p.fill(\n      new Circle({\n        at: c,\n        r: 0.015\n      })\n    );\n    p.fill(\n      new Circle({\n        at: tail,\n        r: 0.015\n      })\n    );\n    p.draw(\n      Path.startAt(c).addCurveTo(tail, {\n        curveSize: p.gaussian({\n          mean: 2,\n          sd: 1\n        })\n      })\n    );\n  });\n};\n\n",
  "Colour Wheel": "const colourWheel = (p: PlayCanvas) => {\n  const dA = Math.PI / 20;\n  const dR = 0.05;\n  for (let a = 0; a < Math.PI * 2; a += dA) {\n    for (let r = 0.1; r < 0.4; r += dR) {\n      p.doProportion(0.6, () => {\n        p.setFillColour((180 * a) / Math.PI, r * 220, 50);\n        p.fill(\n          new HollowArc({\n            at: p.meta.center,\n            r,\n            r2: r - dR,\n            a,\n            a2: a + dA\n          })\n        );\n      });\n    }\n  }\n};\n\n",
  "Colour Palette Generator": "const colourPaletteGenerator = (p: PlayCanvas) => {\n  const baseColour = p.uniformRandomInt({ from: 0, to: 360 });\n\n  p.proportionately([\n    [1, () => p.background(0, 0, 10)],\n    [1, () => p.background(0, 0, 90)]\n  ]);\n\n  const colours = [\n    baseColour + 90,\n    baseColour + 45,\n    baseColour,\n    baseColour - 45,\n    baseColour - 90,\n    baseColour + 180\n  ];\n\n  p.forVertical({ n: 6, margin: 0.1 }, ([x, y], [dX, dY], _c, i) => {\n    const c = colours[i];\n    p.range({ from: x, to: x + dX, n: 6, inclusive: false }, xV => {\n      p.setFillColour(c, 80, 10 + xV * 70);\n      p.fill(\n        new Rect({\n          at: [xV + 0.01, y + 0.01],\n          w: (dX - 0.02 * 6) / 6,\n          h: dY - 0.02\n        })\n      );\n    });\n  });\n};\n\n",
  "Stack Polygons": "const stackPolys = (p: PlayCanvas) => {\n  p.background(320, 10, 90);\n  p.lineWidth = 0.0025;\n  const v = p.uniformRandomInt({ from: 5, to: 8 });\n  const m = p.uniformRandomInt({ from: 30, to: 80 });\n\n  p.times(m, n => {\n    p.setStrokeColour(p.uniformRandomInt({ from: 320, to: 360 }), 80, 50);\n    p.draw(\n      new RegularPolygon({\n        at: p.meta.center,\n        n: v,\n        r: clamp(\n          { from: 0, to: 0.45 * Math.min(p.meta.bottom, p.meta.right) },\n          (n / m) * 0.35 + p.gaussian({ sd: 0.1 })\n        )\n      })\n    );\n  });\n};\n\n",
  "Blob": "const blob = (p: PlayCanvas) => {\n  p.background(205, 55, 95);\n  const paths = p.build(p.times, 3, n =>\n    SimplePath.withPoints(\n      p.build(p.aroundCircle, { n: 12, at: [0, 0] }, (pt, i) =>\n        add(\n          pt,\n          scale([perlin2(i / 12, 1 + n + p.t), perlin2(-i / 12, n + p.t)], 0.25)\n        )\n      )\n    )\n      .close()\n      .chaiken({ n: 3, looped: true })\n  );\n\n  paths.forEach(pt => {\n    p.withTranslation([0.5, 0.5], () => {\n      p.withScale([1.2, 1.2], () => {\n        p.setFillColour(205, 75, 90);\n        p.fill(pt);\n      });\n    });\n  });\n\n  paths.forEach(pt => {\n    p.withTranslation([0.5, 0.5], () => {\n      p.setFillColour(205, 75, 45);\n      p.fill(pt);\n    });\n  });\n};\n\n",
  "Sunburst": "const sunburst = (p: PlayCanvas) => {\n  p.background(0, 0, 10);\n\n  const nextLayer = (\n    layer: { start: number; end: number; depth: number }[]\n  ): { start: number; end: number; depth: number }[] => {\n    return layer\n      .flatMap(({ start, end, depth }) => {\n        const prop = 0.1 + 0.8 * p.random();\n        return p.proportionately([\n          [\n            10,\n            () => [\n              { start, end: (end - start) * prop + start, depth: depth + 1 },\n              { start: (end - start) * prop + start, end, depth: depth + 1 }\n            ]\n          ],\n          [\n            depth,\n            () => [\n              { start, end: (end - start) * prop + start, depth: depth + 1 }\n            ]\n          ],\n          [\n            depth,\n            () => [\n              { start: (end - start) * prop + start, end, depth: depth + 1 }\n            ]\n          ]\n        ]);\n      })\n      .filter(l => l.end - l.start > 0.01);\n  };\n\n  const layerZero: { start: number; end: number; depth: number }[] = [\n    {\n      start: 0,\n      end: Math.PI * 2,\n      depth: 1\n    }\n  ];\n\n  const layers: { start: number; end: number; depth: number }[][] = [layerZero];\n  const n = p.uniformRandomInt({ from: 5, to: 8 });\n  for (let i = 1; i < n; i++) {\n    layers.push(nextLayer(layers[i - 1]));\n  }\n\n  const prop = (1.2 + Math.cos(p.t / 2)) / 2.2;\n  layers.flat().forEach(({ start, end, depth }, i) => {\n    p.setFillColour(i, 90, 60);\n    p.fill(\n      new HollowArc({\n        at: p.meta.center,\n        r: (0.35 * (depth + 1)) / n - 0.005,\n        r2: (0.35 * depth) / n,\n        a: start * prop,\n        a2: end * prop\n      })\n    );\n  });\n};\n\n",
  "Fancy Tiling": "const fancyTiling = (p: PlayCanvas) => {\n  const baseHue = p.uniformRandomInt({ from: 0, to: 360 });\n\n  const generateTile = (): ((\n    x: number,\n    y: number,\n    dX: number,\n    dY: number\n  ) => void) => {\n    const colour: [number, number, number] = [\n      p.uniformRandomInt({ from: baseHue, to: baseHue + 60 }),\n      p.uniformRandomInt({ from: 60, to: 90 }),\n      p.uniformRandomInt({ from: 30, to: 60 })\n    ];\n    const lw = clamp(\n      { from: 0.005, to: 0.02 },\n      p.gaussian({ mean: 0.01, sd: 0.01 })\n    );\n\n    return p.proportionately([\n      [\n        1,\n        () => (x: number, y: number, dX: number, dY: number) => {\n          p.lineWidth = lw;\n          p.setStrokeColour(...colour);\n          p.drawLine([x, y], [x + dX, y + dY]);\n        }\n      ],\n      [\n        1,\n        () => (x: number, y: number, dX: number, dY: number) => {\n          p.lineWidth = lw;\n          p.setStrokeColour(...colour);\n          p.drawLine([x + dX, y], [x, y + dY]);\n        }\n      ],\n      [\n        1,\n        () => (x: number, y: number, dX: number, dY: number) => {\n          p.lineWidth = lw;\n          p.setStrokeColour(...colour);\n          p.drawLine([x, y], [x, y + dY]);\n        }\n      ],\n      [\n        1,\n        () => (x: number, y: number, dX: number, dY: number) => {\n          p.lineWidth = lw;\n          p.setStrokeColour(...colour);\n          p.drawLine([x, y], [x + dX, y]);\n        }\n      ]\n    ]);\n  };\n\n  const rules = arrayOf(\n    p.uniformRandomInt({ from: 2, to: 5, inclusive: true }),\n    generateTile\n  );\n\n  p.forTiling(\n    {\n      n: p.uniformRandomInt({ from: 15, to: 25 }),\n      margin: 0.1,\n      type: \"square\"\n    },\n    ([x, y], [dX, dY]) => {\n      p.proportionately(\n        rules.map(r => [p.poisson(3) + 1, () => r(x, y, dX, dY)])\n      );\n    }\n  );\n};\n\n",
  "Another Tiling": "const anotherTiling = (p: PlayCanvas) => {\n  p.background(240, 20, 90);\n  p.forTiling({ n: 25, margin: 0.1, type: \"square\" }, (at, [dX, dY]) => {\n    p.withTranslation(add(at, scale([dX, dY], 0.5)), () =>\n      p.withRotation(p.sample([0, Math.PI / 2, Math.PI]), () => {\n        p.setFillColour(p.sample([160, 175, 220]), 80, 40);\n        p.fill(\n          SimplePath.withPoints([\n            [-dX / 2, -dY / 2],\n            [dX / 2, -dY / 2],\n            [-dX / 2, dY / 2]\n          ]).close()\n        );\n      })\n    );\n  });\n};\n\n",
  "Lissajous": "const lissajous = (p: PlayCanvas) => {\n  p.background(140, 20, 10);\n  p.lineWidth = 0.005;\n  p.setStrokeColour(140, 80, 60, 0.5);\n\n  const a = 1;\n  const b = 2.4;\n\n  const sp = SimplePath.withPoints([]);\n\n  for (let t = 0; t < 50; t += 0.1) {\n    sp.addPoint([\n      0.5 + 0.4 * Math.sin(a * t),\n      p.meta.bottom * (0.5 + 0.4 * Math.sin(b * t + p.t))\n    ]);\n  }\n\n  p.draw(sp.chaiken({ n: 3 }));\n};\n\n",
  "Sketching Curves": "const sketchingCurves = (p: PlayCanvas) => {\n  p.background(30, 30, 95);\n  p.lineWidth = 0.005;\n  p.setStrokeColour(230, 90, 25, 0.6);\n\n  const points = p.build(\n    p.forHorizontal,\n    { n: 40, margin: 0.05 },\n    (_pt, [dX, dY], [x, y]): Point2D => {\n      return [x, y + dY / 2.2 + 0.1 * perlin2(x * 4, 0)];\n    }\n  );\n\n  const curve = SimplePath.withPoints(points).chaiken({ n: 2 });\n  for (let i = 1; i < 200; i += i / 4) {\n    p.draw(curve);\n    curve\n      .move([0, (-i * p.meta.bottom) / 1024])\n      .transformPoints(pt => [\n        pt[0],\n        pt[1] + 0.017 * p.meta.bottom * perlin2(pt[0] * 4, pt[1] + p.t)\n      ]);\n  }\n};\n\n",
  "Shading In": "const shading = (p: PlayCanvas) => {\n  const delta = 0.005;\n  p.background(50, 80, 85);\n  p.lineWidth = 0.0005;\n  p.forTiling({ n: 8, type: \"square\", margin: 0.1 }, (at, [dX], c, i) => {\n    p.withClipping(\n      new Rect({ at: add(at, [dX / 10, dX / 10]), w: dX * 0.8, h: dX * 0.8 }),\n      () => {\n        p.draw(new Hatching({ at: c, r: dX, a: 0, delta }));\n        p.draw(new Hatching({ at: c, r: dX, a: (Math.PI * i) / 64, delta }));\n      }\n    );\n  });\n};\n\n",
  "Shading Again": "const shading2 = (p: PlayCanvas) => {\n  const delta = 0.005;\n  p.background(0, 80, 85);\n  p.lineWidth = 0.001;\n  p.forTiling({ n: 12, margin: 0.1, type: \"square\" }, (at, [dX, dY], c, i) => {\n    p.withClipping(new Rect({ at, w: dX, h: dY }), () => {\n      p.setStrokeColour(220, 90 - i / 4, 20);\n      p.draw(\n        new Hatching({\n          at: c,\n          r: Math.max(dY, dX),\n          a: (i * Math.PI) / 16,\n          delta: (delta * p.sample([3, 5])) / Math.sqrt(12 + i)\n        })\n      );\n    });\n  });\n};\n\n",
  "Shaded Arcs": "const shadingArcs = (p: PlayCanvas) => {\n  const { center } = p.meta;\n  p.backgroundGradient(\n    new RadialGradient({\n      start: center,\n      end: center,\n      rStart: 0,\n      rEnd: 1,\n      colours: [[0, { h: 50, s: 0, l: 40 }], [1, { h: 50, s: 0, l: 0 }]]\n    })\n  );\n  p.lineWidth = 0.005;\n  p.times(20, () => {\n    p.setStrokeColour(p.sample([20, 40, 50]), 30, 80, 0.85);\n    const a = p.random() * Math.PI * 2;\n    const r = p.random() * 0.4 + 0.2;\n    const dR = p.random() * 0.1 + 0.1;\n    p.withClipping(\n      new HollowArc({\n        at: p.meta.center,\n        r,\n        r2: r - dR,\n        a,\n        a2: a + p.random() * 0.2 + Math.PI / 4\n      }),\n      () => {\n        p.draw(new Hatching({ at: p.meta.center, r: 1, a, delta: 0.01 }));\n      }\n    );\n  });\n};\n\n",
  "Arc Chart": "const arcChart = (p: PlayCanvas) => {\n  p.background(30, 30, 20);\n  const { center: at } = p.meta;\n  p.range({ from: 0, to: Math.PI * 2, inclusive: false, n: 32 }, n => {\n    p.setFillColour((180 * n) / Math.PI, 100, 60);\n    p.fill(\n      new HollowArc({\n        at,\n        a: n,\n        a2: n + Math.PI / 32,\n        r: 0.1 + p.poisson(4) * 0.04 + Math.cos(p.t) * 0.025,\n        r2: 0.05\n      })\n    );\n  });\n};\n\n",
  "Bars": "const bars = (p: PlayCanvas) => {\n  p.background(150, 30, 20);\n  p.forHorizontal({ n: 32, margin: 0.1 }, (at, [dX, dY]) => {\n    const v = (dY * (1 + perlin2(at[0] + p.t, at[1]))) / 2;\n    p.setFillColour(p.sample([190, 170]), 40 + v * 40, 80);\n    p.fill(\n      new Rect({\n        at: [at[0] + dX / 10, at[1] + (dY - v) / 2],\n        h: v,\n        w: dX * 0.8\n      })\n    );\n  });\n};\n\n",
  "Little Abstracts": "const littleAbstracts = (p: PlayCanvas) => {\n  p.background(200, 10, 20);\n  p.forTiling({ n: 8, margin: 0.1, type: \"square\" }, (at, d, c, i) => {\n    p.setFillColour(p.uniformRandomInt({ from: 200, to: 260 }), 50, 50);\n    const rect = new Rect({\n      at: add(at, scale(d, 0.1)),\n      w: d[0] * 0.8,\n      h: d[1] * 0.8\n    });\n    p.fill(rect);\n    p.withClipping(rect, () => {\n      p.setFillColour(0, 0, 100, 0.2);\n      const h = (p.random() * 0.5 + 0.1) * d[1] * 0.8;\n      p.fill(\n        new Rect({\n          at: add(add(at, scale(d, 0.1)), [0, d[1] * 0.8 - h]),\n          w: d[0] * 0.8,\n          h\n        })\n      );\n\n      p.times(3, () => {\n        p.setFillColour(200, p.sample([20, 40]), 90, 0.4);\n        p.fill(\n          new RegularPolygon({\n            at: p.perturb(c, { magnitude: d[0] / 1.5 }),\n            n: p.poisson(4) + 3,\n            r: d[0] / 6\n          })\n        );\n      });\n    });\n  });\n};\n\n"
}